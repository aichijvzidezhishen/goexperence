# goexperence

**增dasd我**
>都说了就拉上来看v才能到家啊是的,非常我的是否我的 我的世界，


--string
## 算法与数据结构
### 
代理

## hw/base
1. 无缓冲 Chan 的发送和接收是否同步  
ch := make(chan int)    `无缓冲的channel`由于没有缓冲发送和接收需要同步.  
ch := make(chan int, 2) `有缓冲channel`不要求发送和接收操作同步.   

---
- channel无缓冲时，发送阻塞直到数据被接收，接收阻塞直到读到数据。
- channel有缓冲时，当缓冲满时发送阻塞，当缓冲空时接收阻塞。  
2. go语言的并发机制以及它所使用的CSP并发模型
3. Golang 中常用的并发模型？
4. JSON 标准库对 nil slice 和 空 slice 的处理是一致的吗？
5. 闭包
6. 协程，线程，进程的区别
7. 互斥锁，读写锁，死锁问题是怎么解决(场景)
    
8. Golang的内存模型（小对象多了会增加内存压力）
9. slice传参有几种方式不改变原始数据
    

    传入数组 **尽量不使用slice指针传参**
    ```
    var a = []int{2,3,5}
    
    func test (a [3]int) {

    }
    ``` 
9.  epoll 、poll、select

10. channel线程安全
11. map 线程安全
12. golang gc
13. goroutine 调度
14. 并发和并行
15. uintptr 和 unsafe.Pointer 的区别

16. 反向代理- 负载均衡器

17. 分布式锁实现
    - redis + lua脚本、memcached、tair
    - 基于数据库实现分布式锁
    - 基于Zookeeper实现分布式锁
17. goroutinue channel mutex 应用场景
    mutex 用于顺序的访问资源
    channel 用于在 goroutine 之间编排计算。
    数据流动
19. log 线程安全么  
    Golang的标准库提供了log的机制，但是该模块的功能较为简单（看似简单，其实他有他的设计思路）。在输出的位置做了线程安全的保护
20. Golang 里的逃逸分析是什么？怎么避免内存逃逸？

21. 配置中心如何保证一致性？

22. Golang 的GC触发时机是什么?

Redis 里数据结构的实现熟悉吗?

22. Etcd的Raft一致性算法原理?

23. 微服务概念.  
选举，负载，服务器优雅启停 

1.  SLB原理.

2.  分布式一直性原则.

3.  如何保证服务宕机造成的分布式服务节点处理问题?

4.  服务发现怎么实现的.


## 数据库
### mysql
1. 索引优化，如何查询优化结果
2. 联合索引 怎么写？ 规则，生效时间
3. 索引原理 b树

### mongodb
1. 事务 session   
    a. dasd

2. 
3. 
## NetWork
1. 公网 内网 专用网络
2. 代理
3. websocket 属于网络分层那一层
4. https 流程是怎样的（公私钥、数字证书、加密、对称加密、非对称加密。）
5. 说说HTTP的状态码，301和302的区别？
是HTTP状态码，302和301都有重定向的含义，但是它们也是有区别的。

301：（永久性转移）请求的网页已被永久移动到新位置。服务器返回此响应时，会自动将请求者转到新位置。
302：（暂时性转移）服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应GET和HEAD请求的301代码类似，会自动将请求者转到不同的位置。


6. 数字签名，数字证书
7. 对称加密和非对称加密
8. dns解析过程
9. csrf 攻击 如何避免
10. websocket 和 socket 区别
11. DoS、DDoS、DRDoS攻击
12. xxs攻击
13. http请求的过程和原理
14. forward 和redirect 的区别
    直接转发方式 
    间接转发方式
15. sql 注入，如何攻击
16. 如何预防sql 注入问题
17. Session和Cookie的区别。
18. IP地址有哪些分类？
19. ARP 协议的工作过程
20. TCP 和 UDP 分别对应的常见应用层协议
21. 保活计时器
22. 服务器出现了大量CLOSE_WAIT状态如何解决
23.  URI和URL的区别
24.  ICMP协议的功能
25.  ping的原理
26.  TCP 的三次握手机制

![Alt text](http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-f795189dd1254b2b5765b0a617198b9c.png)
27. TCP四次挥手过程
28. TCP的粘包和拆包
29. 说说半连接队列和 SYN Flood攻击的关系
30. TCP的滑动窗口
31. TCP的拥塞控制
32. 慢启动算法
33. 拥塞避免算法
34. TCP报文首部有哪些字段，作用
16位端口号：源端口号，主机该报文段是来自哪里；目标端口号，要传给哪个上层协议或应用程序
32位序号：一次TCP通信（从TCP连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。
32位确认号：用作对另一方发送的tcp报文段的响应。其值是收到的TCP报文段的序号值加1。
4位头部长度：表示tcp头部有多少个32bit字（4字节）。因为4位最大能标识15，所以TCP头部最长是60字节。
6位标志位：URG(紧急指针是否有效)，ACk（表示确认号是否有效），PSH（缓冲区尚未填满），RST（表示要求对方重新建立连接），SYN（建立连接消息标志接），FIN（表示告知对方本端要关闭连接了）
16位窗口大小：是TCP流量控制的一个手段。这里说的窗口，指的是接收通告窗口。它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。
16位校验和：由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这个校验不仅包括TCP头部，也包括数据部分。这也是TCP可靠传输的一个重要保障。
16位紧急指针：一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP的紧急指针是发送端向接收端发送紧急数据的方法。
35. 超时重传
36. 重复SACK（D-SACK）
